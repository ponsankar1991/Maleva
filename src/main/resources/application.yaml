spring:
  application:
    name: Maleva
  autoconfigure:
    exclude:
      - org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration
  # Disable Spring Boot Docker Compose dev-services so the app runs standalone
  docker:
    compose:
      enabled: false
  redis:
    host: ${SPRING_REDIS_HOST:localhost}
    port: ${SPRING_REDIS_PORT:6379}
  session:
    # Disable Redis-backed HTTP session store so the application doesn't fail when Redis is unreachable
    store-type: none
  datasource:
    # Default JDBC URL includes encrypt=true and trustServerCertificate=true to avoid SSL certificate path errors
    # For production, prefer to set trustServerCertificate=false and import the server certificate into the JVM truststore
    url: ${SPRING_DATASOURCE_URL:jdbc:sqlserver://103.215.139.8:1433;databaseName=DemoMaleva;encrypt=true;trustServerCertificate=true}
    username: ${SPRING_DATASOURCE_USERNAME:sa}
    password: ${SPRING_DATASOURCE_PASSWORD:Kassamy@123}
    driver-class-name: com.microsoft.sqlserver.jdbc.SQLServerDriver
  jpa:
    show-sql: true
    hibernate:
      ddl-auto: none
    # Explicit Spring Boot alias for the physical naming strategy to use annotated names verbatim
    naming:
      physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
    # Also provide the direct property (redundant but explicit)
    properties:
      hibernate:
        dialect: org.hibernate.dialect.SQLServerDialect
        physical_naming_strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE

jwt:
  secret: changeit
  expiration: 3600
security:
  password-encoding:
    enabled: false